name: Build, Publish and Run UiPath Process

on:
  push:
    branches:
      - main   # or your main branch

jobs:
  build_publish_run:
    runs-on: windows-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v3

    - name: Setup .NET (for future usage if needed)
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '7.0.x'

    - name: Build UiPath project (optional)
      run: |
        echo "You can add UiPath Studio CLI build command here if you have"
      # If no build command, you can skip this

    - name: Upload package to Orchestrator
      id: upload
      shell: pwsh
      env:
        UIPATH_CLIENT_ID: ${{ secrets.UIPATH_CLIENT_ID }}
        UIPATH_USER_KEY: ${{ secrets.UIPATH_USER_KEY }}
        UIPATH_ACCOUNT_LOGICAL_NAME: ${{ secrets.UIPATH_ACCOUNT_LOGICAL_NAME }}
        UIPATH_TENANT: ${{ secrets.UIPATH_TENANT }}
        UIPATH_FOLDER: ${{ secrets.UIPATH_FOLDER }}
      run: |
        # Step 1: Get Auth Token
        $body = @{
          grant_type = "refresh_token"
          client_id = $env:UIPATH_CLIENT_ID
          refresh_token = $env:UIPATH_USER_KEY
          scope = "OR.Jobs"
        } | ConvertTo-Json

        $authResponse = Invoke-RestMethod -Method Post -Uri "https://account.uipath.com/oauth/token" `
          -Headers @{ "Content-Type" = "application/json" } `
          -Body $body

        $accessToken = $authResponse.access_token
        Write-Host "Access Token received"

        # Step 2: Upload .nupkg file
        # Make sure your package exists in the repo or build it above
        $packagePath = "TestAutomationProject.1.0.202484824.nupkg"

        if (!(Test-Path $packagePath)) {
          Write-Error "Package not found at path: $packagePath"
          exit 1
        }

        $uploadUrl = "https://cloud.uipath.com/$($env:UIPATH_ACCOUNT_LOGICAL_NAME)/$($env:UIPATH_TENANT)/odata/Processes/UiPath.Server.Configuration.OData.UploadPackage"

        $form = @{
          file = Get-Item $packagePath
          folderPath = $env:UIPATH_FOLDER
          overwriteExistingPackage = $true
        }

        Invoke-RestMethod -Uri $uploadUrl `
          -Headers @{ Authorization = "Bearer $accessToken" } `
          -Method Post `
          -Form $form

        Write-Host "Package uploaded successfully"

    - name: Start job in Orchestrator (optional)
      shell: pwsh
      env:
        UIPATH_CLIENT_ID: ${{ secrets.UIPATH_CLIENT_ID }}
        UIPATH_USER_KEY: ${{ secrets.UIPATH_USER_KEY }}
        UIPATH_ACCOUNT_LOGICAL_NAME: ${{ secrets.UIPATH_ACCOUNT_LOGICAL_NAME }}
        UIPATH_TENANT: ${{ secrets.UIPATH_TENANT }}
        UIPATH_FOLDER: ${{ secrets.UIPATH_FOLDER }}
      run: |
        # Get Auth Token (same as above)
        $body = @{
          grant_type = "refresh_token"
          client_id = $env:UIPATH_CLIENT_ID
          refresh_token = $env:UIPATH_USER_KEY
          scope = "OR.Jobs"
        } | ConvertTo-Json

        $authResponse = Invoke-RestMethod -Method Post -Uri "https://account.uipath.com/oauth/token" `
          -Headers @{ "Content-Type" = "application/json" } `
          -Body $body

        $accessToken = $authResponse.access_token

        # Fetch Process key (ProcessName should match your published process)
        $processName = "TestAutomationProject" 

        $processesUrl = "https://cloud.uipath.com/$($env:UIPATH_ACCOUNT_LOGICAL_NAME)/$($env:UIPATH_TENANT)/odata/Processes?\$filter=Name eq '$processName'"

        $processesResponse = Invoke-RestMethod -Uri $processesUrl -Headers @{ Authorization = "Bearer $accessToken" }

        if ($processesResponse.value.Count -eq 0) {
          Write-Error "Process '$processName' not found in Orchestrator"
          exit 1
        }

        $processKey = $processesResponse.value[0].Key

        # Start Job
        $startJobUrl = "https://cloud.uipath.com/$($env:UIPATH_ACCOUNT_LOGICAL_NAME)/$($env:UIPATH_TENANT)/odata/Jobs/UiPath.Server.Configuration.OData.StartJobs"

        $jobBody = @{
          startInfo = @{
            ReleaseKey = $processKey
            Strategy = "All" # or "Specific" or "JobsCount"
            # RobotIds = @() # Optional
            # NoOfRobots = 0 # Optional
            # InputArguments = "{}" # Optional JSON string
            # Source = "Manual" # Optional
          }
        } | ConvertTo-Json -Depth 10

        Invoke-RestMethod -Uri $startJobUrl -Headers @{ Authorization = "Bearer $accessToken" } -Method Post -Body $jobBody -ContentType "application/json"

        Write-Host "Job started successfully"
